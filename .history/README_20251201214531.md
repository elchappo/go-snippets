# Go Algorithms & Data Structures Reference

ðŸŽ´ **[View Interactive Flashcards](https://elchappo.github.io/go-snippets/index.html)** - Study these algorithms with an interactive flashcard viewer!

A comprehensive collection of common algorithms and data structures implemented in Go, with complexity analysis, pros/cons, and usage scenarios.

## Table of Contents

- [Getting Started](#getting-started)
- [Array & String Algorithms](#array--string-algorithms)
- [Stack & Queue](#stack--queue)
- [Linked Lists](#linked-lists)
- [Sorting Algorithms](#sorting-algorithms)
- [Search Algorithms](#search-algorithms)
- [Binary Search Trees](#binary-search-trees)
- [Tree Traversal & Operations](#tree-traversal--operations)
- [Dynamic Programming](#dynamic-programming)
- [Contributing](#contributing)
- [Resources](#resources)

---

## Getting Started

### Running Tests
```bash
go test -v
```

### Project Structure
```
go-snippets/
â”œâ”€â”€ README.md           # This comprehensive reference guide
â”œâ”€â”€ index.html          # Interactive flashcard viewer
â”œâ”€â”€ styles.css          # Flashcard styling
â””â”€â”€ *_test.go          # Unit tests for each algorithm
```

### Basic Test Structure
```go
package main

import "testing"

func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a        int
        b        int
        expected int
    }{
        {"Add positive numbers", 2, 3, 5},
        {"Add with zero", 10, 0, 10},
        {"Add negative numbers", -5, -3, -8},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

---

## Array & String Algorithms

### Remove Duplicates From Sorted Array

**Description**: Removes duplicate elements from a sorted array in-place using the two-pointer technique. The algorithm maintains a write pointer that tracks where the next unique element should be placed, while a read pointer scans through the array. Only when a new unique element is found does it get written to the next position.

**Algorithm Approach**: Two-pointer technique
- **Write pointer**: Tracks position for next unique element
- **Read pointer**: Scans through array elements
- **Key insight**: In sorted array, duplicates are adjacent

**Time Complexity**: 
- **Best/Worst/Average**: O(n) - Single pass through array
- **Where n** is the number of elements in the array

**Space Complexity**: O(1) - Only uses two pointer variables

**Pros**:
- In-place modification (no extra space required)
- Single pass through array
- Efficient for sorted arrays
- Simple implementation
- Preserves relative order of unique elements

**Cons**:
- Only works on sorted arrays
- Modifies original array (destructive operation)
- Doesn't actually remove elements, just overwrites

**When to Use**:
- Processing sorted arrays where duplicates should be removed
- Memory-constrained environments requiring in-place operations
- Database query result deduplication
- When you need to preserve the first occurrence of each element

**When NOT to Use**:
- Unsorted arrays (sort first, which takes O(n log n))
- When original array must be preserved
- When you need to count duplicate occurrences

**Usage**: When you need to remove duplicates from a sorted array without using extra space.

**Related Algorithms**: Remove Element, Remove Duplicates from Unsorted Array

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    writeIndex := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[i-1] {
            nums[writeIndex] = nums[i]
            writeIndex++
        }
    }
    return writeIndex
}
```

### Remove Element

**Description**: Removes all instances of a specific value from an array in-place using a single-pass filtering approach. The algorithm maintains a write index that only advances when a non-target element is found, effectively compacting the array by overwriting target values.

**Algorithm Approach**: Single-pass filtering with write pointer
- Iterates once through the array
- Copies non-target elements to the front
- Write index tracks the new array length

**Time Complexity**: 
- **Best/Worst/Average**: O(n) - Single pass required
- **Where n** is the number of elements

**Space Complexity**: O(1) - Only uses one index variable

**Pros**:
- In-place modification (minimal memory usage)
- Works on unsorted arrays
- Simple implementation
- Efficient single-pass solution
- Can handle multiple occurrences efficiently

**Cons**:
- Modifies original array
- Order may not be preserved (unstable)
- Doesn't shrink the underlying array capacity

**When to Use**:
- Filtering specific values from arrays in-place
- Memory-constrained scenarios
- Preprocessing data before further operations
- Removing invalid or sentinel values from datasets

**When NOT to Use**:
- When original array must be preserved
- When order must be maintained exactly
- When you need to track removed elements

**Usage**: When you need to filter out specific values from an array without allocating new memory.

**Related Algorithms**: Remove Duplicates, Move Zeroes

```go
func removeElement(nums []int, val int) int {
    if len(nums) == 0 {
        return 0
    }

    nIndex := 0
    for _, num := range nums {
        if num != val {
            nums[nIndex] = num
            nIndex++
        }
    }
    return nIndex
}
```

### Concatenation of Array

**Description**: Creates a new array by concatenating the original array with itself, effectively doubling its length. This operation creates a sequence where the original array is repeated twice consecutively.

**Algorithm Approach**: Array duplication using built-in append
- Leverages Go's `append` with spread operator (`...`)
- Creates new underlying array
- Simple one-line operation

**Time Complexity**: 
- **Best/Worst/Average**: O(n) - Must copy all elements
- **Where n** is the number of elements in original array

**Space Complexity**: O(n) - Creates new array of size 2n

**Pros**:
- Simple and readable implementation
- Uses idiomatic Go append function
- Clear intent and purpose
- Efficient built-in implementation

**Cons**:
- Creates new array (memory allocation overhead)
- Not in-place operation
- Doubles memory usage

**When to Use**:
- Creating circular/cyclic patterns
- Preprocessing for sliding window algorithms
- Testing algorithms that need repeated data
- Generating periodic sequences

**When NOT to Use**:
- Very large arrays (memory concerns)
- When in-place modification is preferred
- Real-time systems with strict memory constraints

**Usage**: When you need to duplicate array elements in sequence for pattern generation or algorithm preprocessing.

**Related Algorithms**: Array Rotation, Circular Array Simulation

```go
func getConcatenation(nums []int) []int {
    return append(nums, nums...)
}
```

**Alternative Implementation** (manual approach):
```go
func getConcatenation(nums []int) []int {
    n := len(nums)
    result := make([]int, 2*n)
    
    for i := 0; i < n; i++ {
        result[i] = nums[i]
        result[i+n] = nums[i]
    }
    
    return result
}
```

---

## Stack & Queue

### Valid Parentheses

**Description**: Validates if a string of brackets/parentheses is properly balanced and correctly nested using a stack data structure. The algorithm processes each character, pushing expected closing brackets onto a stack for opening brackets, and verifying that closing brackets match the most recent opening bracket.

**Algorithm Approach**: Stack-based matching
- **Opening brackets**: Push expected closing bracket to stack
- **Closing brackets**: Pop and verify match with current character
- **Final check**: Stack must be empty (all brackets closed)

**Time Complexity**: 
- **Best/Worst/Average**: O(n) - Single pass through string
- **Where n** is the length of the string

**Space Complexity**: 
- **Worst case**: O(n) - All opening brackets (e.g., "((((")
- **Best case**: O(1) - Alternating brackets (e.g., "()()")

**Pros**:
- Handles multiple bracket types `()`, `{}`, `[]`
- Clear and maintainable code
- Efficient single-pass solution
- Catches all invalid patterns (unmatched, wrong order, extra brackets)
- Optimal time complexity

**Cons**:
- Requires extra space for stack
- Cannot identify specific error location
- Only validates, doesn't correct imbalances

**When to Use**:
- Validating mathematical expressions
- Compiler/parser bracket validation
- Code editor syntax checking
- HTML/XML tag matching
- Expression evaluation preprocessing

**When NOT to Use**:
- When you need to identify where the error is
- For non-bracket matching problems
- When memory is extremely constrained

**Usage**: Validating balanced expressions in compilers, parsers, or mathematical expressions.

**Common Pitfalls**:
- Forgetting to check if stack is empty at the end
- Not handling empty strings
- Integer overflow with very long strings

**Related Algorithms**: Expression Evaluation, HTML Tag Matching

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        '(': ')',
        '{': '}',
        '[': ']',
    }

    for _, ch := range s {
        if expected, isOpen := pairs[ch]; isOpen {
            // Opening bracket: push expected closing bracket
            stack = append(stack, expected)
        } else {
            // Closing bracket: verify it matches top of stack
            if len(stack) == 0 || stack[len(stack)-1] != ch {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}
```

### Min Stack

**Description**: A specialized stack data structure that supports push, pop, top, and retrieving the minimum element in constant O(1) time. This is achieved by maintaining two parallel stacks: one for actual values and one for tracking the minimum at each level.

**Algorithm Approach**: Parallel stack technique
- **Main stack**: Stores all pushed values
- **Min stack**: Stores running minimum at each level
- **Key insight**: Track min as stack grows/shrinks

**Time Complexity**: 
- **All operations**: O(1) - Push, Pop, Top, GetMin
- No iteration required for any operation

**Space Complexity**: O(n) - Two stacks storing n elements

**Pros**:
- Constant time minimum retrieval
- All standard stack operations remain O(1)
- Simple implementation
- No complex data structures needed
- Maintains min even after pop operations

**Cons**:
- Uses double the space (two stacks)
- Increased memory footprint
- Push operation slightly more expensive (two operations)

**When to Use**:
- Stock price tracking (min/max over time)
- Algorithm problems requiring O(1) min access
- Undo/redo with constraint tracking
- Window minimum tracking
- Financial applications (tracking lowest price)

**When NOT to Use**:
- Memory-constrained environments
- When min is rarely needed (cheaper to calculate on demand)
- When you need median or other statistics (use different structure)

**Usage**: When you need to track the minimum value in a stack efficiently (e.g., stock price tracking, sliding window minimums).

**Related Algorithms**: Max Stack, Monotonic Stack

```go
type MinStack struct {
    stack []int
    min   []int
}

func Constructor() MinStack {
    return MinStack{}
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    
    // Track minimum at this level
    if len(this.min) == 0 || val <= this.min[len(this.min)-1] {
        this.min = append(this.min, val)
    } else {
        this.min = append(this.min, this.min[len(this.min)-1])
    }
}

func (this *MinStack) Pop() {
    if len(this.stack) == 0 {
        return
    }
    this.stack = this.stack[:len(this.stack)-1]
    this.min = this.min[:len(this.min)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min)-1]
}
```

### Implement Stack Using Queues

**Description**: Implements a Last-In-First-Out (LIFO) stack using First-In-First-Out (FIFO) queue operations. This demonstrates how to transform a FIFO structure into a LIFO structure by reordering elements on each push operation.

**Algorithm Approach**: Queue rotation on push
- **Push operation**: Add element, then rotate queue
- **Rotation**: Move all previous elements to end of queue
- **Result**: Most recent element is at front

**Time Complexity**: 
- **Push**: O(n) - Must rotate all elements
- **Pop**: O(1) - Simple dequeue from front
- **Top**: O(1) - Access front element
- **Where n** is current number of elements

**Space Complexity**: O(n) - Single queue storing n elements

**Pros**:
- Demonstrates data structure conversion
- Educational value for understanding structures
- Simple conceptual approach
- Pop and Top are efficient

**Cons**:
- Push operation is O(n) vs standard O(1) stack
- Less efficient than native stack implementation
- Not practical for production use
- High cost for frequent push operations

**When to Use**:
- Academic purposes or technical interviews
- When only queue operations are available
- Learning data structure relationships
- Demonstrating algorithmic thinking

**When NOT to Use**:
- Production code (use native stack)
- Performance-critical applications
- Frequent push operations
- Real-world applications (unless constrained to queues)

**Usage**: Academic purposes or when only queue operations are available.

**Related Algorithms**: Implement Queue Using Stacks

```go
type MyStack struct {
    q []int
}

func Constructor() MyStack {
    return MyStack{q: []int{}}
}

func (this *MyStack) Push(x int) {
    this.q = append(this.q, x)
    // Rotate all previous elements to back
    for i := 0; i < len(this.q)-1; i++ {
        this.q = append(this.q, this.q[0])
        this.q = this.q[1:]
    }
}

func (this *MyStack) Pop() int {
    top := this.q[0]
    this.q = this.q[1:]
    return top
}

func (this *MyStack) Top() int {
    return this.q[0]
}

func (this *MyStack) Empty() bool {
    return len(this.q) == 0
}
```

### Design Browser History

**Description**: Simulates browser navigation with back/forward functionality using an array-based approach. The implementation tracks the current position in a history array and allows navigation backward and forward through visited pages.

**Algorithm Approach**: Array with current index pointer
- **Visit**: Truncate forward history, append new page, move index
- **Back**: Decrease index (bounded by 0)
- **Forward**: Increase index (bounded by history length)

**Time Complexity**: 
- **Visit**: O(1) - Array append and index update
- **Back/Forward**: O(1) - Simple index manipulation

**Space Complexity**: O(n) where n is number of visited pages

**Pros**:
- Simple array-based implementation
- Efficient navigation operations (all O(1))
- Clear state management
- Easy to understand and maintain
- Supports arbitrary back/forward steps

**Cons**:
- Stores all history in memory
- Visiting new page discards forward history
- Memory grows with browsing (no automatic
