# Go Algorithms & Data Structures Reference

A comprehensive collection of common algorithms and data structures implemented in Go, with complexity analysis, pros/cons, and usage scenarios.

## Table of Contents

- [Getting Started](#getting-started)
- [Array & String Algorithms](#array--string-algorithms)
- [Stack & Queue](#stack--queue)
- [Linked Lists](#linked-lists)
- [Sorting Algorithms](#sorting-algorithms)
- [Search Algorithms](#search-algorithms)
- [Binary Search Trees](#binary-search-trees)
- [Tree Traversal & Operations](#tree-traversal--operations)
- [Dynamic Programming](#dynamic-programming)

---

## Getting Started

### Running Tests
```bash
go test -v
```

### Basic Test Structure
```go
package main

import "testing"

func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a        int
        b        int
        expected int
    }{
        {"Add positive numbers", 2, 3, 5},
        {"Add with zero", 10, 0, 10},
        {"Add negative numbers", -5, -3, -8},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

---

## Array & String Algorithms

### Remove Duplicates From Sorted Array

**Description**: Removes duplicate elements from a sorted array in-place using two-pointer technique.

**Time Complexity**: O(n)  
**Space Complexity**: O(1)

**Pros**:
- In-place modification (no extra space)
- Single pass through array
- Efficient for sorted arrays

**Cons**:
- Only works on sorted arrays
- Modifies original array

**Usage**: When you need to remove duplicates from a sorted array without using extra space.

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    writeIndex := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[i-1] {
            nums[writeIndex] = nums[i]
            writeIndex++
        }
    }
    return writeIndex
}
```

### Remove Element

**Description**: Removes all instances of a specific value from an array in-place.

**Time Complexity**: O(n)  
**Space Complexity**: O(1)

**Pros**:
- In-place modification
- Works on unsorted arrays
- Simple implementation

**Cons**:
- Modifies original array
- Order may not be preserved

**Usage**: When you need to filter out specific values from an array without allocating new memory.

```go
func removeElement(nums []int, val int) int {
    if len(nums) == 0 {
        return 0
    }

    nIndex := 0
    for _, num := range nums {
        if num != val {
            nums[nIndex] = num
            nIndex++
        }
    }
    return nIndex
}
```

### Concatenation of Array

**Description**: Creates a new array by concatenating the original array with itself.

**Time Complexity**: O(n)  
**Space Complexity**: O(n)

**Pros**:
- Simple and readable
- Built-in Go append function

**Cons**:
- Creates new array (memory allocation)

**Usage**: When you need to duplicate array elements in sequence.

```go
func getConcatenation(nums []int) []int {
    return append(nums, nums...)
}
```

---

## Stack & Queue

### Valid Parentheses

**Description**: Validates if a string of brackets is properly balanced using a stack.

**Time Complexity**: O(n)  
**Space Complexity**: O(n)

**Pros**:
- Handles multiple bracket types
- Clear and maintainable
- Efficient single-pass solution

**Cons**:
- Requires extra space for stack

**Usage**: Validating balanced expressions in compilers, parsers, or mathematical expressions.

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        '(': ')',
        '{': '}',
        '[': ']',
    }

    for _, ch := range s {
        if expected, isOpen := pairs[ch]; isOpen {
            stack = append(stack, expected)
        } else {
            if len(stack) == 0 || stack[len(stack)-1] != ch {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}
```

### Min Stack

**Description**: Stack that supports push, pop, top, and retrieving minimum element in O(1) time.

**Time Complexity**: O(1) for all operations  
**Space Complexity**: O(n)

**Pros**:
- Constant time minimum retrieval
- All standard stack operations remain O(1)

**Cons**:
- Uses double the space (two stacks)

**Usage**: When you need to track the minimum value in a stack efficiently (e.g., stock price tracking).

```go
type MinStack struct {
    stack []int
    min   []int
}

func Constructor() MinStack {
    return MinStack{}
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    
    if len(this.min) == 0 || val <= this.min[len(this.min)-1] {
        this.min = append(this.min, val)
    } else {
        this.min = append(this.min, this.min[len(this.min)-1])
    }
}

func (this *MinStack) Pop() {
    if len(this.stack) == 0 {
        return
    }
    this.stack = this.stack[:len(this.stack)-1]
    this.min = this.min[:len(this.min)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min)-1]
}
```

### Implement Stack Using Queues

**Description**: Implements a LIFO stack using FIFO queue operations.

**Time Complexity**: O(n) for push, O(1) for pop/top  
**Space Complexity**: O(n)

**Pros**:
- Demonstrates data structure conversion
- Educational value

**Cons**:
- Push operation is O(n)
- Less efficient than native stack

**Usage**: Academic purposes or when only queue operations are available.

```go
type MyStack struct {
    q []int
}

func Constructor() MyStack {
    return MyStack{q: []int{}}
}

func (this *MyStack) Push(x int) {
    this.q = append(this.q, x)
    for i := 0; i < len(this.q)-1; i++ {
        this.q = append(this.q, this.q[0])
        this.q = this.q[1:]
    }
}

func (this *MyStack) Pop() int {
    top := this.q[0]
    this.q = this.q[1:]
    return top
}

func (this *MyStack) Top() int {
    return this.q[0]
}

func (this *MyStack) Empty() bool {
    return len(this.q) == 0
}
```

### Design Browser History

**Description**: Simulates browser navigation with back/forward functionality.

**Time Complexity**: O(1) for all operations  
**Space Complexity**: O(n) where n is number of visited pages

**Pros**:
- Simple array-based implementation
- Efficient navigation operations
- Clear state management

**Cons**:
- Stores all history in memory

**Usage**: Browser history, undo/redo systems, navigation stacks.

```go
type BrowserHistory struct {
    history []string
    index   int
}

func Constructor(homepage string) BrowserHistory {
    return BrowserHistory{
        history: []string{homepage},
        index:   0,
    }
}

func (this *BrowserHistory) Visit(url string) {
    this.history = this.history[:this.index+1]
    this.history = append(this.history, url)
    this.index++
}

func (this *BrowserHistory) Back(steps int) string {
    if this.index-steps < 0 {
        this.index = 0
    } else {
        this.index -= steps
    }
    return this.history[this.index]
}

func (this *BrowserHistory) Forward(steps int) string {
    if this.index+steps >= len(this.history) {
        this.index = len(this.history) - 1
    } else {
        this.index += steps
    }
    return this.history[this.index]
}
```

### Number of Students Unable to Eat Lunch

**Description**: Counts students who cannot get their preferred sandwich using counting approach.

**Time Complexity**: O(n)  
**Space Complexity**: O(1)

**Pros**:
- Efficient counting solution
- No simulation needed
- Constant extra space

**Cons**:
- Less intuitive than simulation

**Usage**: Queue matching problems, resource allocation scenarios.

```go
func countStudents(students []int, sandwiches []int) int {
    count := []int{0, 0}
    for _, s := range students {
        count[s]++
    }

    for _, sandwich := range sandwiches {
        if count[sandwich] == 0 {
            break
        }
        count[sandwich]--
    }
    return count[0] + count[1]
}
```

---

## Linked Lists

### Reverse Linked List

**Description**: Reverses a singly linked list using recursion.

**Time Complexity**: O(n)  
**Space Complexity**: O(n) due to recursion stack

**Pros**:
- Clean recursive solution
- Easy to understand

**Cons**:
- Uses call stack space
- Risk of stack overflow for very long lists

**Usage**: List reversal, interview questions. [NeetCode Solution](https://neetcode.io/solutions/reverse-linked-list)

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }

    newHead := head
    if head.Next != nil {
        newHead = reverseList(head.Next)
        head.Next.Next = head
    }
    head.Next = nil

    return newHead
}
```

### Merge Two Sorted Linked Lists

**Description**: Merges two sorted linked lists into one sorted list.

**Time Complexity**: O(n + m)  
**Space Complexity**: O(1)

**Pros**:
- In-place merging
- Maintains sorted order
- Efficient single pass

**Cons**:
- Modifies original lists

**Usage**: Merge sort for linked lists, combining sorted data streams.

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{}
    node := dummy

    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            node.Next = list1
            list1 = list1.Next
        } else {
            node.Next = list2
            list2 = list2.Next
        }
        node = node.Next
    }

    node.Next = list1
    if list1 == nil {
        node.Next = list2
    }

    return dummy.Next
}
```

### Design Linked List

**Description**: Custom implementation of a singly linked list with common operations.

**Time Complexity**: O(n) for get/add/delete at index, O(1) for add at head  
**Space Complexity**: O(1) per operation

**Pros**:
- Full control over implementation
- Efficient head operations
- Tracks size for validation

**Cons**:
- Linear time for index-based operations
- More complex than using built-in structures

**Usage**: When you need a custom linked list implementation with specific requirements.

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

type MyLinkedList struct {
    head *ListNode
    size int
}

func Constructor() MyLinkedList {
    return MyLinkedList{
        head: &ListNode{Next: nil},
        size: 0,
    }
}

func (this *MyLinkedList) getPrev(index int) *ListNode {
    cur := this.head
    for i := 0; i < index; i++ {
        cur = cur.Next
    }
    return cur
}

func (this *MyLinkedList) Get(index int) int {
    if index < 0 || index >= this.size {
        return -1
    }
    return this.getPrev(index).Next.Val
}

func (this *MyLinkedList) AddAtHead(val int) {
    this.AddAtIndex(0, val)
}

func (this *MyLinkedList) AddAtTail(val int) {
    this.AddAtIndex(this.size, val)
}

func (this *MyLinkedList) AddAtIndex(index int, val int) {
    if index < 0 || index > this.size {
        return
    }
    prev := this.getPrev(index)
    node := &ListNode{Val: val, Next: prev.Next}
    prev.Next = node
    this.size++
}

func (this *MyLinkedList) DeleteAtIndex(index int) {
    if index < 0 || index >= this.size {
        return
    }
    prev := this.getPrev(index)
    prev.Next = prev.Next.Next
    this.size--
}
```

---

## Sorting Algorithms

### Comparison Table

| Algorithm      | Time (Best) | Time (Avg) | Time (Worst) | Space    | Stable |
| -------------- | ----------- | ---------- | ------------ | -------- | ------ |
| Insertion Sort | O(n)        | O(n²)      | O(n²)        | O(1)     | ✓      |
| Merge Sort     | O(n log n)  | O(n log n) | O(n log n)   | O(n)     | ✓      |
| Quick Sort     | O(n log n)  | O(n log n) | O(n²)        | O(log n) | ✗      |
| Bucket Sort    | O(n)        | O(n)       | O(n)         | O(n)     | ✗      |

### Insertion Sort

![Insertion Sort](https://blog.boot.dev/img/800/insertionsort.gif)

**Description**: Builds sorted array one element at a time by inserting elements into their correct position.

**Time Complexity**: O(n²) average, O(n) best case  
**Space Complexity**: O(1)

**Pros**:
- Simple implementation
- Efficient for small datasets
- Stable sort
- In-place sorting
- Adaptive (efficient for nearly sorted data)

**Cons**:
- Quadratic time for large datasets
- Not suitable for large arrays

**Usage**: Small datasets, nearly sorted data, or when simplicity is preferred over performance.

```go
func InsertionSort(arr []int) []int {
    for i := 1; i < len(arr); i++ {
        j := i
        for j > 0 && arr[j] < arr[j-1] {
            arr[j], arr[j-1] = arr[j-1], arr[j]
            j--
        }
    }
    return arr
}
```

**With Snapshots** (for visualization):
```go
func insertionSort(pairs []Pair) [][]Pair {
    result := make([][]Pair, 0, len(pairs))
