<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Algorithms - Flashcards</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>üöÄ Go Algorithms Flashcards</h1>
            <p>Learn with interactive flashcards ‚Ä¢ Use ‚Üê ‚Üí arrow keys to navigate</p>
        </header>
        <div class="controls">
            <div class="section-nav" id="nav">
                <button class="section-btn active" onclick="filterSection('all')">All</button>
            </div>
            <button class="reset-btn" onclick="resetProgress()">Reset Progress</button>
        </div>
        <div class="progress-info" id="progress-info">Loading...</div>
        <div class="card-selector" id="card-selector" style="display: none;">
            <span class="card-selector-label">Jump to Card:</span>
            <div class="card-selector-grid" id="card-selector-grid"></div>
        </div>
        <div id="card-wrapper" class="card-wrapper">
            <div class="loading">Loading algorithms from README.md...</div>
        </div>
        <div class="keyboard-hint">üí° Tip: Use ‚Üê ‚Üí arrow keys to navigate ‚Ä¢ Space to mark as known</div>
    </div>
    <div class="print-content hidden" id="print-content"></div>
    <script>
        let algorithms = [];
        let filteredAlgorithms = [];
        let currentFilter = 'all';
        let currentIndex = 0;
        let knownCards = new Set();

        const sectionMap = {
            'Array & String Algorithms': 'array',
            'Stack & Queue': 'stack',
            'Linked Lists': 'linked',
            'Sorting Algorithms': 'sorting',
            'Search Algorithms': 'search',
            'Binary Search Trees': 'tree',
            'Tree Traversal & Operations': 'tree',
            'Dynamic Programming': 'dp'
        };

        function loadKnownCards() {
            const saved = localStorage.getItem('knownCards');
            if (saved) knownCards = new Set(JSON.parse(saved));
        }

        function saveKnownCards() {
            localStorage.setItem('knownCards', JSON.stringify([...knownCards]));
        }

        function resetProgress() {
            if (confirm('Reset all progress? This will mark all cards as unknown.')) {
                knownCards.clear();
                saveKnownCards();
                updateFilteredAlgorithms();
                renderCurrentCard();
            }
        }

        function parseReadme(content) {
            const algos = [];
            content.split(/^### /m).slice(1).forEach(section => {
                const lines = section.split('\n');
                const title = lines[0].trim();
                if (!title || title.includes('Main') || title.includes('Tests') || title.includes('Comparison Table') || title.includes('Algorithm Name')) return;

                // Extract description
                let description = '';
                const descMatch = section.match(/\*\*Description\*\*:\s*(.+?)(?=\n\n|\*\*Algorithm)/s);
                if (descMatch) {
                    description = descMatch[1].trim();
                } else {
                    description = `Implementation of ${title}`;
                }

                // Extract algorithm approach
                let approach = [];
                const approachSection = section.match(/\*\*Algorithm Approach\*\*:(.+?)(?=\n\*\*Time Complexity\*\*)/s);
                if (approachSection) {
                    const approachText = approachSection[1].trim();
                    // Check if it's a simple description or bullet points
                    if (approachText.includes('- **')) {
                        // Structured approach with labeled items
                        const items = approachText.match(/- \*\*(.+?)\*\*:\s*(.+?)(?=\n-|\n\*\*|$)/gs);
                        if (items) {
                            approach = items.map(item => {
                                const match = item.match(/- \*\*(.+?)\*\*:\s*(.+)/s);
                                return match ? { label: match[1].trim(), text: match[2].trim() } : null;
                            }).filter(Boolean);
                        }
                    } else if (approachText.includes('\n- ')) {
                        // Simple bullet list
                        const lines = approachText.split('\n').filter(l => l.trim().startsWith('-'));
                        approach = lines.map(line => {
                            const text = line.replace(/^-\s*/, '').trim();
                            return { label: '', text: text };
                        });
                    } else {
                        // Single line description
                        approach = [{ label: '', text: approachText }];
                    }
                }

                // Extract time complexity (multi-line)
                let timeComplexity = [];
                const timeSection = section.match(/\*\*Time Complexity\*\*:\s*\n((?:- .+\n?)+)/);
                if (timeSection) {
                    timeComplexity = timeSection[1].split('\n').filter(t => t.trim()).map(t => t.replace(/^- /, '').trim());
                } else {
                    const timeMatch = section.match(/\*\*Time Complexity\*\*:\s*(.+?)(?=\n\n|\*\*)/s);
                    if (timeMatch) {
                        timeComplexity = [timeMatch[1].trim()];
                    }
                }

                // Extract space complexity
                let spaceComplexity = 'O(1)';
                const spaceMatch = section.match(/\*\*Space Complexity\*\*:\s*(.+?)(?=\n\n|\*\*)/s);
                if (spaceMatch) {
                    spaceComplexity = spaceMatch[1].trim();
                }

                // Extract pros
                let pros = [];
                const prosMatch = section.match(/\*\*Pros\*\*:\n((?:- .+\n?)+)/);
                if (prosMatch) {
                    pros = prosMatch[1].split('\n').filter(p => p.trim()).map(p => p.replace(/^- /, '').trim());
                }

                // Extract cons
                let cons = [];
                const consMatch = section.match(/\*\*Cons\*\*:\n((?:- .+\n?)+)/);
                if (consMatch) {
                    cons = consMatch[1].split('\n').filter(c => c.trim()).map(c => c.replace(/^- /, '').trim());
                }

                // Extract when to use
                let whenToUse = [];
                const whenToUseMatch = section.match(/\*\*When to Use\*\*:\n((?:- .+\n?)+)/);
                if (whenToUseMatch) {
                    whenToUse = whenToUseMatch[1].split('\n').filter(w => w.trim()).map(w => w.replace(/^- /, '').trim());
                }

                // Extract when NOT to use
                let whenNotToUse = [];
                const whenNotToUseMatch = section.match(/\*\*When NOT to Use\*\*:\n((?:- .+\n?)+)/);
                if (whenNotToUseMatch) {
                    whenNotToUse = whenNotToUseMatch[1].split('\n').filter(w => w.trim()).map(w => w.replace(/^- /, '').trim());
                }

                // Extract usage summary
                let usage = '';
                const usageMatch = section.match(/\*\*Usage\*\*:\s*(.+?)(?=\n\n|\*\*Common|\*\*Related|```)/s);
                if (usageMatch) {
                    usage = usageMatch[1].trim();
                }

                // Extract common pitfalls
                let pitfalls = [];
                const pitfallsMatch = section.match(/\*\*Common Pitfalls\*\*(?:\s*\*\(optional\)\*)?\s*:\n((?:- .+\n?)+)/);
                if (pitfallsMatch) {
                    pitfalls = pitfallsMatch[1].split('\n').filter(p => p.trim()).map(p => p.replace(/^- /, '').trim());
                }

                // Extract related algorithms
                let relatedAlgorithms = '';
                const relatedMatch = section.match(/\*\*Related Algorithms\*\*:\s*(.+?)(?=\n\n|```|\[)/s);
                if (relatedMatch) {
                    relatedAlgorithms = relatedMatch[1].trim();
                }

                // Extract code
                let code = '';
                const codeMatch = section.match(/```go\n([\s\S]*?)```/);
                if (codeMatch) code = codeMatch[1].trim();

                // Determine category
                let category = 'all';
                const sectionHeader = content.substring(0, content.indexOf('### ' + title));
                if (sectionHeader.includes('## Array & String')) category = 'array';
                else if (sectionHeader.includes('## Stack & Queue')) category = 'stack';
                else if (sectionHeader.includes('## Linked Lists')) category = 'linked';
                else if (sectionHeader.includes('## Sorting')) category = 'sorting';
                else if (sectionHeader.includes('## Search')) category = 'search';
                else if (sectionHeader.includes('## Binary Search Trees') || sectionHeader.includes('## Tree')) category = 'tree';
                else if (sectionHeader.includes('## Dynamic')) category = 'dp';

                if (code) {
                    algos.push({
                        title,
                        description,
                        approach,
                        timeComplexity,
                        spaceComplexity,
                        pros,
                        cons,
                        whenToUse,
                        whenNotToUse,
                        usage,
                        pitfalls,
                        relatedAlgorithms,
                        code,
                        category
                    });
                }
            });
            return algos;
        }

        function updateFilteredAlgorithms() {
            filteredAlgorithms = algorithms.filter(algo => {
                const matchesFilter = currentFilter === 'all' || algo.category === currentFilter;
                const isNotKnown = !knownCards.has(algo.title);
                return matchesFilter && isNotKnown;
            });
            if (currentIndex >= filteredAlgorithms.length) currentIndex = Math.max(0, filteredAlgorithms.length - 1);
        }

        function filterSection(category) {
            currentFilter = category;
            currentIndex = 0;
            document.querySelectorAll('.section-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            updateFilteredAlgorithms();
            renderCurrentCard();
        }

        function updateProgress() {
            const total = algorithms.filter(a => currentFilter === 'all' || a.category === currentFilter).length;
            const known = [...knownCards].filter(title => {
                const algo = algorithms.find(a => a.title === title);
                return algo && (currentFilter === 'all' || algo.category === currentFilter);
            }).length;
            const remaining = filteredAlgorithms.length;
            document.getElementById('progress-info').textContent =
                `Card ${currentIndex + 1} of ${remaining} ‚Ä¢ ${known} known of ${total} total`;
        }

        function renderCurrentCard() {
            const wrapper = document.getElementById('card-wrapper');
            if (filteredAlgorithms.length === 0) {
                wrapper.innerHTML = '<div class="loading">üéâ All cards completed! Click "Reset Progress" to start over.</div>';
                return;
            }

            const algo = filteredAlgorithms[currentIndex];
            const isKnown = knownCards.has(algo.title);

            // Get category label
            const categoryLabels = {
                'array': 'Array & String Algorithms',
                'stack': 'Stack & Queue',
                'linked': 'Linked Lists',
                'sorting': 'Sorting Algorithms',
                'search': 'Search Algorithms',
                'tree': 'Binary Search Trees / Tree Operations',
                'dp': 'Dynamic Programming'
            };
            const categoryLabel = categoryLabels[algo.category] || 'General';

            // Build algorithm approach section
            let approachHTML = '';
            if (algo.approach && algo.approach.length > 0) {
                approachHTML = `
                    <div class="approach-section">
                        <h4>üéØ Algorithm Approach</h4>
                        <ul class="approach-list">
                            ${algo.approach.map(item => {
                    if (item.label) {
                        return `<li><strong>${item.label}:</strong> ${item.text}</li>`;
                    } else {
                        return `<li>${item.text}</li>`;
                    }
                }).join('')}
                        </ul>
                    </div>
                `;
            }

            // Build complexity section
            const timeComplexityHTML = Array.isArray(algo.timeComplexity)
                ? algo.timeComplexity.map(t => `<div>${t}</div>`).join('')
                : algo.timeComplexity;

            const complexityHTML = `
                <div class="complexity">
                    <div class="complexity-item">
                        <div class="complexity-label">Time Complexity</div>
                        <div class="complexity-value">${timeComplexityHTML}</div>
                    </div>
                    <div class="complexity-item">
                        <div class="complexity-label">Space Complexity</div>
                        <div class="complexity-value">${algo.spaceComplexity}</div>
                    </div>
                </div>
            `;

            // Build pros/cons section
            let prosConsHTML = '';
            if (algo.pros.length > 0 || algo.cons.length > 0) {
                prosConsHTML = '<div class="pros-cons">';
                if (algo.pros.length > 0) {
                    prosConsHTML += `
                        <div class="pros">
                            <h4>‚úÖ Pros</h4>
                            <ul>
                                ${algo.pros.map(pro => `<li>${pro}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }
                if (algo.cons.length > 0) {
                    prosConsHTML += `
                        <div class="cons">
                            <h4>‚ö†Ô∏è Cons</h4>
                            <ul>
                                ${algo.cons.map(con => `<li>${con}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }
                prosConsHTML += '</div>';
            }

            // Build when to use section
            let whenToUseHTML = '';
            if (algo.whenToUse && algo.whenToUse.length > 0) {
                whenToUseHTML = `
                    <div class="when-to-use">
                        <h4>‚ú® When to Use</h4>
                        <ul>
                            ${algo.whenToUse.map(w => `<li>${w}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Build when NOT to use section
            let whenNotToUseHTML = '';
            if (algo.whenNotToUse && algo.whenNotToUse.length > 0) {
                whenNotToUseHTML = `
                    <div class="when-not-to-use">
                        <h4>üö´ When NOT to Use</h4>
                        <ul>
                            ${algo.whenNotToUse.map(w => `<li>${w}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Build usage summary section
            const usageHTML = algo.usage ? `
                <div class="usage">
                    <div class="usage-label">üí° Usage Summary</div>
                    <div class="usage-text">${algo.usage}</div>
                </div>
            ` : '';

            // Build common pitfalls section
            let pitfallsHTML = '';
            if (algo.pitfalls && algo.pitfalls.length > 0) {
                pitfallsHTML = `
                    <div class="pitfalls">
                        <h4>‚ö° Common Pitfalls</h4>
                        <ul>
                            ${algo.pitfalls.map(p => `<li>${p}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Build related algorithms section
            let relatedHTML = '';
            if (algo.relatedAlgorithms) {
                relatedHTML = `
                    <div class="related">
                        <div class="related-label">üîó Related Algorithms</div>
                        <div class="related-text">${algo.relatedAlgorithms}</div>
                    </div>
                `;
            }

            wrapper.innerHTML = `
                <div class="card">
                    <div class="card-category">${categoryLabel}</div>
                    <div class="card-title">${algo.title}</div>
                    <div class="card-description">${algo.description}</div>
                    ${approachHTML}
                    ${complexityHTML}
                    ${prosConsHTML}
                    ${whenToUseHTML}
                    ${whenNotToUseHTML}
                    ${usageHTML}
                    ${pitfallsHTML}
                    ${relatedHTML}
                    <div class="code-section">
                        <div class="code-header">
                            <span class="code-label">üíª Go Implementation</span>
                            <button class="print-code-btn" onclick="printCode()">üñ®Ô∏è Print Code</button>
                        </div>
                        <div class="code-block">${algo.code}</div>
                    </div>
                    <div class="card-actions">
                        <div class="known-checkbox" onclick="toggleKnown()">
                            <input type="checkbox" id="known-check" ${isKnown ? 'checked' : ''}>
                            <label for="known-check">Mark as Known</label>
                        </div>
                        <div class="navigation">
                            <button class="nav-btn" onclick="previousCard()">‚Üê Previous</button>
                            <button class="nav-btn" onclick="nextCard()">Next ‚Üí</button>
                        </div>
                    </div>
                </div>
            `;
            updateProgress();
            renderCardSelector();
        }

        function toggleKnown() {
            const algo = filteredAlgorithms[currentIndex];
            if (knownCards.has(algo.title)) {
                knownCards.delete(algo.title);
            } else {
                knownCards.add(algo.title);
            }
            saveKnownCards();
            updateFilteredAlgorithms();
            renderCurrentCard();
        }

        function previousCard() {
            if (currentIndex > 0) {
                currentIndex--;
            } else {
                // Loop to the end
                currentIndex = filteredAlgorithms.length - 1;
            }
            renderCurrentCard();
            updateCardSelector();
        }

        function nextCard() {
            if (currentIndex < filteredAlgorithms.length - 1) {
                currentIndex++;
            } else {
                // Loop back to the start
                currentIndex = 0;
            }
            renderCurrentCard();
            updateCardSelector();
        }

        function jumpToCard(index) {
            currentIndex = index;
            renderCurrentCard();
            updateCardSelector();
        }

        function renderCardSelector() {
            const selector = document.getElementById('card-selector');
            const grid = document.getElementById('card-selector-grid');

            if (filteredAlgorithms.length === 0) {
                selector.style.display = 'none';
                return;
            }

            selector.style.display = 'block';
            grid.innerHTML = filteredAlgorithms.map((algo, index) => {
                const isKnown = knownCards.has(algo.title);
                const isActive = index === currentIndex;
                const classes = ['card-number-btn'];
                if (isActive) classes.push('active');
                if (isKnown) classes.push('known');

                return `<button class="${classes.join(' ')}" onclick="jumpToCard(${index})" title="${algo.title}">${index + 1}</button>`;
            }).join('');
        }

        function updateCardSelector() {
            const buttons = document.querySelectorAll('.card-number-btn');
            buttons.forEach((btn, index) => {
                btn.classList.remove('active');
                if (index === currentIndex) {
                    btn.classList.add('active');
                }
            });
        }

        function printCode() {
            const algo = filteredAlgorithms[currentIndex];
            const printContent = document.getElementById('print-content');
            printContent.innerHTML = `
                <h1>${algo.title}</h1>
                <h2>Go Implementation</h2>
                <pre class="code-block">${algo.code}</pre>
            `;
            window.print();
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                previousCard();
            } else if (e.key === 'ArrowRight') {
                nextCard();
            } else if (e.key === ' ') {
                e.preventDefault();
                toggleKnown();
            }
        });

        // Load README and initialize
        async function loadReadme() {
            try {
                loadKnownCards();
                const response = await fetch('https://raw.githubusercontent.com/elchappo/go-snippets/refs/heads/main/README.md');
                const content = await response.text();
                algorithms = parseReadme(content);
                updateFilteredAlgorithms();
                renderCurrentCard();
            } catch (error) {
                document.getElementById('card-wrapper').innerHTML =
                    '<div class="loading">Error loading README.md from GitHub. Please check your internet connection.</div>';
                console.error('Error:', error);
            }
        }

        loadReadme();
    </script>
</body>

</html>